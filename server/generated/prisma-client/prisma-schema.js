module.exports = {
        typeDefs: // Code generated by Prisma (prisma@1.23.0-test.3). DO NOT EDIT.
  // Please don't change this file manually but run `prisma generate` to update it.
  // For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

/* GraphQL */ `type AggregateDays {
  count: Int!
}

type AggregateFeature {
  count: Int!
}

type AggregateGeoPoint {
  count: Int!
}

type AggregateGoal {
  count: Int!
}

type AggregateLocation {
  count: Int!
}

type AggregateProgress {
  count: Int!
}

type AggregateSession {
  count: Int!
}

type AggregateUser {
  count: Int!
}

type BatchPayload {
  count: Long!
}

scalar DateTime

type Days {
  id: ID!
  title: String!
}

type DaysConnection {
  pageInfo: PageInfo!
  edges: [DaysEdge]!
  aggregate: AggregateDays!
}

input DaysCreateInput {
  id: ID
  title: String!
}

input DaysCreateManyInput {
  create: [DaysCreateInput!]
  connect: [DaysWhereUniqueInput!]
}

type DaysEdge {
  node: Days!
  cursor: String!
}

enum DaysOrderByInput {
  id_ASC
  id_DESC
  title_ASC
  title_DESC
}

type DaysPreviousValues {
  id: ID!
  title: String!
}

input DaysScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  title: String
  title_not: String
  title_in: [String!]
  title_not_in: [String!]
  title_lt: String
  title_lte: String
  title_gt: String
  title_gte: String
  title_contains: String
  title_not_contains: String
  title_starts_with: String
  title_not_starts_with: String
  title_ends_with: String
  title_not_ends_with: String
  AND: [DaysScalarWhereInput!]
  OR: [DaysScalarWhereInput!]
  NOT: [DaysScalarWhereInput!]
}

type DaysSubscriptionPayload {
  mutation: MutationType!
  node: Days
  updatedFields: [String!]
  previousValues: DaysPreviousValues
}

input DaysSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: DaysWhereInput
  AND: [DaysSubscriptionWhereInput!]
  OR: [DaysSubscriptionWhereInput!]
  NOT: [DaysSubscriptionWhereInput!]
}

input DaysUpdateDataInput {
  title: String
}

input DaysUpdateInput {
  title: String
}

input DaysUpdateManyDataInput {
  title: String
}

input DaysUpdateManyInput {
  create: [DaysCreateInput!]
  update: [DaysUpdateWithWhereUniqueNestedInput!]
  upsert: [DaysUpsertWithWhereUniqueNestedInput!]
  delete: [DaysWhereUniqueInput!]
  connect: [DaysWhereUniqueInput!]
  set: [DaysWhereUniqueInput!]
  disconnect: [DaysWhereUniqueInput!]
  deleteMany: [DaysScalarWhereInput!]
  updateMany: [DaysUpdateManyWithWhereNestedInput!]
}

input DaysUpdateManyMutationInput {
  title: String
}

input DaysUpdateManyWithWhereNestedInput {
  where: DaysScalarWhereInput!
  data: DaysUpdateManyDataInput!
}

input DaysUpdateWithWhereUniqueNestedInput {
  where: DaysWhereUniqueInput!
  data: DaysUpdateDataInput!
}

input DaysUpsertWithWhereUniqueNestedInput {
  where: DaysWhereUniqueInput!
  update: DaysUpdateDataInput!
  create: DaysCreateInput!
}

input DaysWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  title: String
  title_not: String
  title_in: [String!]
  title_not_in: [String!]
  title_lt: String
  title_lte: String
  title_gt: String
  title_gte: String
  title_contains: String
  title_not_contains: String
  title_starts_with: String
  title_not_starts_with: String
  title_ends_with: String
  title_not_ends_with: String
  AND: [DaysWhereInput!]
  OR: [DaysWhereInput!]
  NOT: [DaysWhereInput!]
}

input DaysWhereUniqueInput {
  id: ID
}

type Feature {
  id: ID!
  title: String!
}

type FeatureConnection {
  pageInfo: PageInfo!
  edges: [FeatureEdge]!
  aggregate: AggregateFeature!
}

input FeatureCreateInput {
  id: ID
  title: String!
}

input FeatureCreateManyInput {
  create: [FeatureCreateInput!]
  connect: [FeatureWhereUniqueInput!]
}

type FeatureEdge {
  node: Feature!
  cursor: String!
}

enum FeatureOrderByInput {
  id_ASC
  id_DESC
  title_ASC
  title_DESC
}

type FeaturePreviousValues {
  id: ID!
  title: String!
}

input FeatureScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  title: String
  title_not: String
  title_in: [String!]
  title_not_in: [String!]
  title_lt: String
  title_lte: String
  title_gt: String
  title_gte: String
  title_contains: String
  title_not_contains: String
  title_starts_with: String
  title_not_starts_with: String
  title_ends_with: String
  title_not_ends_with: String
  AND: [FeatureScalarWhereInput!]
  OR: [FeatureScalarWhereInput!]
  NOT: [FeatureScalarWhereInput!]
}

type FeatureSubscriptionPayload {
  mutation: MutationType!
  node: Feature
  updatedFields: [String!]
  previousValues: FeaturePreviousValues
}

input FeatureSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: FeatureWhereInput
  AND: [FeatureSubscriptionWhereInput!]
  OR: [FeatureSubscriptionWhereInput!]
  NOT: [FeatureSubscriptionWhereInput!]
}

input FeatureUpdateDataInput {
  title: String
}

input FeatureUpdateInput {
  title: String
}

input FeatureUpdateManyDataInput {
  title: String
}

input FeatureUpdateManyInput {
  create: [FeatureCreateInput!]
  update: [FeatureUpdateWithWhereUniqueNestedInput!]
  upsert: [FeatureUpsertWithWhereUniqueNestedInput!]
  delete: [FeatureWhereUniqueInput!]
  connect: [FeatureWhereUniqueInput!]
  set: [FeatureWhereUniqueInput!]
  disconnect: [FeatureWhereUniqueInput!]
  deleteMany: [FeatureScalarWhereInput!]
  updateMany: [FeatureUpdateManyWithWhereNestedInput!]
}

input FeatureUpdateManyMutationInput {
  title: String
}

input FeatureUpdateManyWithWhereNestedInput {
  where: FeatureScalarWhereInput!
  data: FeatureUpdateManyDataInput!
}

input FeatureUpdateWithWhereUniqueNestedInput {
  where: FeatureWhereUniqueInput!
  data: FeatureUpdateDataInput!
}

input FeatureUpsertWithWhereUniqueNestedInput {
  where: FeatureWhereUniqueInput!
  update: FeatureUpdateDataInput!
  create: FeatureCreateInput!
}

input FeatureWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  title: String
  title_not: String
  title_in: [String!]
  title_not_in: [String!]
  title_lt: String
  title_lte: String
  title_gt: String
  title_gte: String
  title_contains: String
  title_not_contains: String
  title_starts_with: String
  title_not_starts_with: String
  title_ends_with: String
  title_not_ends_with: String
  AND: [FeatureWhereInput!]
  OR: [FeatureWhereInput!]
  NOT: [FeatureWhereInput!]
}

input FeatureWhereUniqueInput {
  id: ID
}

type GeoPoint {
  id: ID!
  boundary: Json!
}

type GeoPointConnection {
  pageInfo: PageInfo!
  edges: [GeoPointEdge]!
  aggregate: AggregateGeoPoint!
}

input GeoPointCreateInput {
  id: ID
  boundary: Json!
}

input GeoPointCreateManyInput {
  create: [GeoPointCreateInput!]
  connect: [GeoPointWhereUniqueInput!]
}

type GeoPointEdge {
  node: GeoPoint!
  cursor: String!
}

enum GeoPointOrderByInput {
  id_ASC
  id_DESC
  boundary_ASC
  boundary_DESC
}

type GeoPointPreviousValues {
  id: ID!
  boundary: Json!
}

input GeoPointScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  AND: [GeoPointScalarWhereInput!]
  OR: [GeoPointScalarWhereInput!]
  NOT: [GeoPointScalarWhereInput!]
}

type GeoPointSubscriptionPayload {
  mutation: MutationType!
  node: GeoPoint
  updatedFields: [String!]
  previousValues: GeoPointPreviousValues
}

input GeoPointSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: GeoPointWhereInput
  AND: [GeoPointSubscriptionWhereInput!]
  OR: [GeoPointSubscriptionWhereInput!]
  NOT: [GeoPointSubscriptionWhereInput!]
}

input GeoPointUpdateDataInput {
  boundary: Json
}

input GeoPointUpdateInput {
  boundary: Json
}

input GeoPointUpdateManyDataInput {
  boundary: Json
}

input GeoPointUpdateManyInput {
  create: [GeoPointCreateInput!]
  update: [GeoPointUpdateWithWhereUniqueNestedInput!]
  upsert: [GeoPointUpsertWithWhereUniqueNestedInput!]
  delete: [GeoPointWhereUniqueInput!]
  connect: [GeoPointWhereUniqueInput!]
  set: [GeoPointWhereUniqueInput!]
  disconnect: [GeoPointWhereUniqueInput!]
  deleteMany: [GeoPointScalarWhereInput!]
  updateMany: [GeoPointUpdateManyWithWhereNestedInput!]
}

input GeoPointUpdateManyMutationInput {
  boundary: Json
}

input GeoPointUpdateManyWithWhereNestedInput {
  where: GeoPointScalarWhereInput!
  data: GeoPointUpdateManyDataInput!
}

input GeoPointUpdateWithWhereUniqueNestedInput {
  where: GeoPointWhereUniqueInput!
  data: GeoPointUpdateDataInput!
}

input GeoPointUpsertWithWhereUniqueNestedInput {
  where: GeoPointWhereUniqueInput!
  update: GeoPointUpdateDataInput!
  create: GeoPointCreateInput!
}

input GeoPointWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  AND: [GeoPointWhereInput!]
  OR: [GeoPointWhereInput!]
  NOT: [GeoPointWhereInput!]
}

input GeoPointWhereUniqueInput {
  id: ID
}

type Goal {
  id: ID!
  hours: Int!
  days(where: DaysWhereInput, orderBy: DaysOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Days!]
}

type GoalConnection {
  pageInfo: PageInfo!
  edges: [GoalEdge]!
  aggregate: AggregateGoal!
}

input GoalCreateInput {
  id: ID
  hours: Int!
  days: DaysCreateManyInput
}

type GoalEdge {
  node: Goal!
  cursor: String!
}

enum GoalOrderByInput {
  id_ASC
  id_DESC
  hours_ASC
  hours_DESC
}

type GoalPreviousValues {
  id: ID!
  hours: Int!
}

type GoalSubscriptionPayload {
  mutation: MutationType!
  node: Goal
  updatedFields: [String!]
  previousValues: GoalPreviousValues
}

input GoalSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: GoalWhereInput
  AND: [GoalSubscriptionWhereInput!]
  OR: [GoalSubscriptionWhereInput!]
  NOT: [GoalSubscriptionWhereInput!]
}

input GoalUpdateInput {
  hours: Int
  days: DaysUpdateManyInput
}

input GoalUpdateManyMutationInput {
  hours: Int
}

input GoalWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  hours: Int
  hours_not: Int
  hours_in: [Int!]
  hours_not_in: [Int!]
  hours_lt: Int
  hours_lte: Int
  hours_gt: Int
  hours_gte: Int
  days_every: DaysWhereInput
  days_some: DaysWhereInput
  days_none: DaysWhereInput
  AND: [GoalWhereInput!]
  OR: [GoalWhereInput!]
  NOT: [GoalWhereInput!]
}

input GoalWhereUniqueInput {
  id: ID
}

scalar Json

type Location {
  id: ID!
  title: String!
  address: String!
  features(where: FeatureWhereInput, orderBy: FeatureOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Feature!]
  boundaries(where: GeoPointWhereInput, orderBy: GeoPointOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [GeoPoint!]
}

type LocationConnection {
  pageInfo: PageInfo!
  edges: [LocationEdge]!
  aggregate: AggregateLocation!
}

input LocationCreateInput {
  id: ID
  title: String!
  address: String!
  features: FeatureCreateManyInput
  boundaries: GeoPointCreateManyInput
}

input LocationCreateManyInput {
  create: [LocationCreateInput!]
  connect: [LocationWhereUniqueInput!]
}

type LocationEdge {
  node: Location!
  cursor: String!
}

enum LocationOrderByInput {
  id_ASC
  id_DESC
  title_ASC
  title_DESC
  address_ASC
  address_DESC
}

type LocationPreviousValues {
  id: ID!
  title: String!
  address: String!
}

input LocationScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  title: String
  title_not: String
  title_in: [String!]
  title_not_in: [String!]
  title_lt: String
  title_lte: String
  title_gt: String
  title_gte: String
  title_contains: String
  title_not_contains: String
  title_starts_with: String
  title_not_starts_with: String
  title_ends_with: String
  title_not_ends_with: String
  address: String
  address_not: String
  address_in: [String!]
  address_not_in: [String!]
  address_lt: String
  address_lte: String
  address_gt: String
  address_gte: String
  address_contains: String
  address_not_contains: String
  address_starts_with: String
  address_not_starts_with: String
  address_ends_with: String
  address_not_ends_with: String
  AND: [LocationScalarWhereInput!]
  OR: [LocationScalarWhereInput!]
  NOT: [LocationScalarWhereInput!]
}

type LocationSubscriptionPayload {
  mutation: MutationType!
  node: Location
  updatedFields: [String!]
  previousValues: LocationPreviousValues
}

input LocationSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: LocationWhereInput
  AND: [LocationSubscriptionWhereInput!]
  OR: [LocationSubscriptionWhereInput!]
  NOT: [LocationSubscriptionWhereInput!]
}

input LocationUpdateDataInput {
  title: String
  address: String
  features: FeatureUpdateManyInput
  boundaries: GeoPointUpdateManyInput
}

input LocationUpdateInput {
  title: String
  address: String
  features: FeatureUpdateManyInput
  boundaries: GeoPointUpdateManyInput
}

input LocationUpdateManyDataInput {
  title: String
  address: String
}

input LocationUpdateManyInput {
  create: [LocationCreateInput!]
  update: [LocationUpdateWithWhereUniqueNestedInput!]
  upsert: [LocationUpsertWithWhereUniqueNestedInput!]
  delete: [LocationWhereUniqueInput!]
  connect: [LocationWhereUniqueInput!]
  set: [LocationWhereUniqueInput!]
  disconnect: [LocationWhereUniqueInput!]
  deleteMany: [LocationScalarWhereInput!]
  updateMany: [LocationUpdateManyWithWhereNestedInput!]
}

input LocationUpdateManyMutationInput {
  title: String
  address: String
}

input LocationUpdateManyWithWhereNestedInput {
  where: LocationScalarWhereInput!
  data: LocationUpdateManyDataInput!
}

input LocationUpdateWithWhereUniqueNestedInput {
  where: LocationWhereUniqueInput!
  data: LocationUpdateDataInput!
}

input LocationUpsertWithWhereUniqueNestedInput {
  where: LocationWhereUniqueInput!
  update: LocationUpdateDataInput!
  create: LocationCreateInput!
}

input LocationWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  title: String
  title_not: String
  title_in: [String!]
  title_not_in: [String!]
  title_lt: String
  title_lte: String
  title_gt: String
  title_gte: String
  title_contains: String
  title_not_contains: String
  title_starts_with: String
  title_not_starts_with: String
  title_ends_with: String
  title_not_ends_with: String
  address: String
  address_not: String
  address_in: [String!]
  address_not_in: [String!]
  address_lt: String
  address_lte: String
  address_gt: String
  address_gte: String
  address_contains: String
  address_not_contains: String
  address_starts_with: String
  address_not_starts_with: String
  address_ends_with: String
  address_not_ends_with: String
  features_every: FeatureWhereInput
  features_some: FeatureWhereInput
  features_none: FeatureWhereInput
  boundaries_every: GeoPointWhereInput
  boundaries_some: GeoPointWhereInput
  boundaries_none: GeoPointWhereInput
  AND: [LocationWhereInput!]
  OR: [LocationWhereInput!]
  NOT: [LocationWhereInput!]
}

input LocationWhereUniqueInput {
  id: ID
}

scalar Long

type Mutation {
  createDays(data: DaysCreateInput!): Days!
  updateDays(data: DaysUpdateInput!, where: DaysWhereUniqueInput!): Days
  updateManyDayses(data: DaysUpdateManyMutationInput!, where: DaysWhereInput): BatchPayload!
  upsertDays(where: DaysWhereUniqueInput!, create: DaysCreateInput!, update: DaysUpdateInput!): Days!
  deleteDays(where: DaysWhereUniqueInput!): Days
  deleteManyDayses(where: DaysWhereInput): BatchPayload!
  createFeature(data: FeatureCreateInput!): Feature!
  updateFeature(data: FeatureUpdateInput!, where: FeatureWhereUniqueInput!): Feature
  updateManyFeatures(data: FeatureUpdateManyMutationInput!, where: FeatureWhereInput): BatchPayload!
  upsertFeature(where: FeatureWhereUniqueInput!, create: FeatureCreateInput!, update: FeatureUpdateInput!): Feature!
  deleteFeature(where: FeatureWhereUniqueInput!): Feature
  deleteManyFeatures(where: FeatureWhereInput): BatchPayload!
  createGeoPoint(data: GeoPointCreateInput!): GeoPoint!
  updateGeoPoint(data: GeoPointUpdateInput!, where: GeoPointWhereUniqueInput!): GeoPoint
  updateManyGeoPoints(data: GeoPointUpdateManyMutationInput!, where: GeoPointWhereInput): BatchPayload!
  upsertGeoPoint(where: GeoPointWhereUniqueInput!, create: GeoPointCreateInput!, update: GeoPointUpdateInput!): GeoPoint!
  deleteGeoPoint(where: GeoPointWhereUniqueInput!): GeoPoint
  deleteManyGeoPoints(where: GeoPointWhereInput): BatchPayload!
  createGoal(data: GoalCreateInput!): Goal!
  updateGoal(data: GoalUpdateInput!, where: GoalWhereUniqueInput!): Goal
  updateManyGoals(data: GoalUpdateManyMutationInput!, where: GoalWhereInput): BatchPayload!
  upsertGoal(where: GoalWhereUniqueInput!, create: GoalCreateInput!, update: GoalUpdateInput!): Goal!
  deleteGoal(where: GoalWhereUniqueInput!): Goal
  deleteManyGoals(where: GoalWhereInput): BatchPayload!
  createLocation(data: LocationCreateInput!): Location!
  updateLocation(data: LocationUpdateInput!, where: LocationWhereUniqueInput!): Location
  updateManyLocations(data: LocationUpdateManyMutationInput!, where: LocationWhereInput): BatchPayload!
  upsertLocation(where: LocationWhereUniqueInput!, create: LocationCreateInput!, update: LocationUpdateInput!): Location!
  deleteLocation(where: LocationWhereUniqueInput!): Location
  deleteManyLocations(where: LocationWhereInput): BatchPayload!
  createProgress(data: ProgressCreateInput!): Progress!
  updateProgress(data: ProgressUpdateInput!, where: ProgressWhereUniqueInput!): Progress
  updateManyProgresses(data: ProgressUpdateManyMutationInput!, where: ProgressWhereInput): BatchPayload!
  upsertProgress(where: ProgressWhereUniqueInput!, create: ProgressCreateInput!, update: ProgressUpdateInput!): Progress!
  deleteProgress(where: ProgressWhereUniqueInput!): Progress
  deleteManyProgresses(where: ProgressWhereInput): BatchPayload!
  createSession(data: SessionCreateInput!): Session!
  updateSession(data: SessionUpdateInput!, where: SessionWhereUniqueInput!): Session
  updateManySessions(data: SessionUpdateManyMutationInput!, where: SessionWhereInput): BatchPayload!
  upsertSession(where: SessionWhereUniqueInput!, create: SessionCreateInput!, update: SessionUpdateInput!): Session!
  deleteSession(where: SessionWhereUniqueInput!): Session
  deleteManySessions(where: SessionWhereInput): BatchPayload!
  createUser(data: UserCreateInput!): User!
  updateUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User
  updateManyUsers(data: UserUpdateManyMutationInput!, where: UserWhereInput): BatchPayload!
  upsertUser(where: UserWhereUniqueInput!, create: UserCreateInput!, update: UserUpdateInput!): User!
  deleteUser(where: UserWhereUniqueInput!): User
  deleteManyUsers(where: UserWhereInput): BatchPayload!
}

enum MutationType {
  CREATED
  UPDATED
  DELETED
}

interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

type Progress {
  id: ID!
  duration: Float!
  completion: Float!
}

type ProgressConnection {
  pageInfo: PageInfo!
  edges: [ProgressEdge]!
  aggregate: AggregateProgress!
}

input ProgressCreateInput {
  id: ID
  duration: Float!
  completion: Float!
}

type ProgressEdge {
  node: Progress!
  cursor: String!
}

enum ProgressOrderByInput {
  id_ASC
  id_DESC
  duration_ASC
  duration_DESC
  completion_ASC
  completion_DESC
}

type ProgressPreviousValues {
  id: ID!
  duration: Float!
  completion: Float!
}

type ProgressSubscriptionPayload {
  mutation: MutationType!
  node: Progress
  updatedFields: [String!]
  previousValues: ProgressPreviousValues
}

input ProgressSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ProgressWhereInput
  AND: [ProgressSubscriptionWhereInput!]
  OR: [ProgressSubscriptionWhereInput!]
  NOT: [ProgressSubscriptionWhereInput!]
}

input ProgressUpdateInput {
  duration: Float
  completion: Float
}

input ProgressUpdateManyMutationInput {
  duration: Float
  completion: Float
}

input ProgressWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  duration: Float
  duration_not: Float
  duration_in: [Float!]
  duration_not_in: [Float!]
  duration_lt: Float
  duration_lte: Float
  duration_gt: Float
  duration_gte: Float
  completion: Float
  completion_not: Float
  completion_in: [Float!]
  completion_not_in: [Float!]
  completion_lt: Float
  completion_lte: Float
  completion_gt: Float
  completion_gte: Float
  AND: [ProgressWhereInput!]
  OR: [ProgressWhereInput!]
  NOT: [ProgressWhereInput!]
}

input ProgressWhereUniqueInput {
  id: ID
}

type Query {
  days(where: DaysWhereUniqueInput!): Days
  dayses(where: DaysWhereInput, orderBy: DaysOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Days]!
  daysesConnection(where: DaysWhereInput, orderBy: DaysOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): DaysConnection!
  feature(where: FeatureWhereUniqueInput!): Feature
  features(where: FeatureWhereInput, orderBy: FeatureOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Feature]!
  featuresConnection(where: FeatureWhereInput, orderBy: FeatureOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): FeatureConnection!
  geoPoint(where: GeoPointWhereUniqueInput!): GeoPoint
  geoPoints(where: GeoPointWhereInput, orderBy: GeoPointOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [GeoPoint]!
  geoPointsConnection(where: GeoPointWhereInput, orderBy: GeoPointOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): GeoPointConnection!
  goal(where: GoalWhereUniqueInput!): Goal
  goals(where: GoalWhereInput, orderBy: GoalOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Goal]!
  goalsConnection(where: GoalWhereInput, orderBy: GoalOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): GoalConnection!
  location(where: LocationWhereUniqueInput!): Location
  locations(where: LocationWhereInput, orderBy: LocationOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Location]!
  locationsConnection(where: LocationWhereInput, orderBy: LocationOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): LocationConnection!
  progress(where: ProgressWhereUniqueInput!): Progress
  progresses(where: ProgressWhereInput, orderBy: ProgressOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Progress]!
  progressesConnection(where: ProgressWhereInput, orderBy: ProgressOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ProgressConnection!
  session(where: SessionWhereUniqueInput!): Session
  sessions(where: SessionWhereInput, orderBy: SessionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Session]!
  sessionsConnection(where: SessionWhereInput, orderBy: SessionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): SessionConnection!
  user(where: UserWhereUniqueInput!): User
  users(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [User]!
  usersConnection(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): UserConnection!
  node(id: ID!): Node
}

type Session {
  id: ID!
  timeStart: DateTime!
  timeEnd: DateTime!
  locations(where: LocationWhereInput, orderBy: LocationOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Location!]
  mood: Float
  journal: String
}

type SessionConnection {
  pageInfo: PageInfo!
  edges: [SessionEdge]!
  aggregate: AggregateSession!
}

input SessionCreateInput {
  id: ID
  timeStart: DateTime!
  timeEnd: DateTime!
  locations: LocationCreateManyInput
  mood: Float
  journal: String
}

type SessionEdge {
  node: Session!
  cursor: String!
}

enum SessionOrderByInput {
  id_ASC
  id_DESC
  timeStart_ASC
  timeStart_DESC
  timeEnd_ASC
  timeEnd_DESC
  mood_ASC
  mood_DESC
  journal_ASC
  journal_DESC
}

type SessionPreviousValues {
  id: ID!
  timeStart: DateTime!
  timeEnd: DateTime!
  mood: Float
  journal: String
}

type SessionSubscriptionPayload {
  mutation: MutationType!
  node: Session
  updatedFields: [String!]
  previousValues: SessionPreviousValues
}

input SessionSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: SessionWhereInput
  AND: [SessionSubscriptionWhereInput!]
  OR: [SessionSubscriptionWhereInput!]
  NOT: [SessionSubscriptionWhereInput!]
}

input SessionUpdateInput {
  timeStart: DateTime
  timeEnd: DateTime
  locations: LocationUpdateManyInput
  mood: Float
  journal: String
}

input SessionUpdateManyMutationInput {
  timeStart: DateTime
  timeEnd: DateTime
  mood: Float
  journal: String
}

input SessionWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  timeStart: DateTime
  timeStart_not: DateTime
  timeStart_in: [DateTime!]
  timeStart_not_in: [DateTime!]
  timeStart_lt: DateTime
  timeStart_lte: DateTime
  timeStart_gt: DateTime
  timeStart_gte: DateTime
  timeEnd: DateTime
  timeEnd_not: DateTime
  timeEnd_in: [DateTime!]
  timeEnd_not_in: [DateTime!]
  timeEnd_lt: DateTime
  timeEnd_lte: DateTime
  timeEnd_gt: DateTime
  timeEnd_gte: DateTime
  locations_every: LocationWhereInput
  locations_some: LocationWhereInput
  locations_none: LocationWhereInput
  mood: Float
  mood_not: Float
  mood_in: [Float!]
  mood_not_in: [Float!]
  mood_lt: Float
  mood_lte: Float
  mood_gt: Float
  mood_gte: Float
  journal: String
  journal_not: String
  journal_in: [String!]
  journal_not_in: [String!]
  journal_lt: String
  journal_lte: String
  journal_gt: String
  journal_gte: String
  journal_contains: String
  journal_not_contains: String
  journal_starts_with: String
  journal_not_starts_with: String
  journal_ends_with: String
  journal_not_ends_with: String
  AND: [SessionWhereInput!]
  OR: [SessionWhereInput!]
  NOT: [SessionWhereInput!]
}

input SessionWhereUniqueInput {
  id: ID
}

type Subscription {
  days(where: DaysSubscriptionWhereInput): DaysSubscriptionPayload
  feature(where: FeatureSubscriptionWhereInput): FeatureSubscriptionPayload
  geoPoint(where: GeoPointSubscriptionWhereInput): GeoPointSubscriptionPayload
  goal(where: GoalSubscriptionWhereInput): GoalSubscriptionPayload
  location(where: LocationSubscriptionWhereInput): LocationSubscriptionPayload
  progress(where: ProgressSubscriptionWhereInput): ProgressSubscriptionPayload
  session(where: SessionSubscriptionWhereInput): SessionSubscriptionPayload
  user(where: UserSubscriptionWhereInput): UserSubscriptionPayload
}

type User {
  id: ID!
  email: String!
  password: String!
}

type UserConnection {
  pageInfo: PageInfo!
  edges: [UserEdge]!
  aggregate: AggregateUser!
}

input UserCreateInput {
  id: ID
  email: String!
  password: String!
}

type UserEdge {
  node: User!
  cursor: String!
}

enum UserOrderByInput {
  id_ASC
  id_DESC
  email_ASC
  email_DESC
  password_ASC
  password_DESC
}

type UserPreviousValues {
  id: ID!
  email: String!
  password: String!
}

type UserSubscriptionPayload {
  mutation: MutationType!
  node: User
  updatedFields: [String!]
  previousValues: UserPreviousValues
}

input UserSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: UserWhereInput
  AND: [UserSubscriptionWhereInput!]
  OR: [UserSubscriptionWhereInput!]
  NOT: [UserSubscriptionWhereInput!]
}

input UserUpdateInput {
  email: String
  password: String
}

input UserUpdateManyMutationInput {
  email: String
  password: String
}

input UserWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  email: String
  email_not: String
  email_in: [String!]
  email_not_in: [String!]
  email_lt: String
  email_lte: String
  email_gt: String
  email_gte: String
  email_contains: String
  email_not_contains: String
  email_starts_with: String
  email_not_starts_with: String
  email_ends_with: String
  email_not_ends_with: String
  password: String
  password_not: String
  password_in: [String!]
  password_not_in: [String!]
  password_lt: String
  password_lte: String
  password_gt: String
  password_gte: String
  password_contains: String
  password_not_contains: String
  password_starts_with: String
  password_not_starts_with: String
  password_ends_with: String
  password_not_ends_with: String
  AND: [UserWhereInput!]
  OR: [UserWhereInput!]
  NOT: [UserWhereInput!]
}

input UserWhereUniqueInput {
  id: ID
}
`
      }
    